// Generated by CoffeeScript 2.0.2
var assert, check, checkObj, converter, delay, mapObject, markdown, mean, sleep, zip,shuffle,getRandom,setCharAt,rep;

converter = new showdown.Converter();

markdown = function(txt) {
  // Remove leading spaces so as not to interpret indented
  // blocks as code blocks. Use fenced code blocks instead.
  return converter.makeHtml(txt.replace(/^[ ]+/gm, ''));
};

delay = function(time, func) {
  return setTimeout(func, time);
};

sleep = function(ms) {
  return new Promise(function(resolve) {
    return window.setTimeout(resolve, ms);
  });
};

zip = function(...rows) {
  return rows[0].map(function(_, c) {
    return rows.map(function(row) {
      return row[c];
    });
  });
};

mapObject = function(obj, fn) {
  return Object.keys(obj).reduce(function(res, key) {
    res[key] = fn(obj[key]);
    return res;
  }, {});
};

mean = function(xs) {
  return (xs.reduce((function(acc, x) {
    return acc + x;
  }))) / xs.length;
};

checkObj = function(obj, keys) {
  var i, k, len;
  if (keys == null) {
    keys = Object.keys(obj);
  }
  for (i = 0, len = keys.length; i < len; i++) {
    k = keys[i];
    if (obj[k] === void 0) {
      console.log('Bad Object: ', obj);
      throw new Error(`${k} is undefined`);
    }
  }
  return obj;
};

check = function(name, val) {
  if (val === void 0) {
    throw new Error(`${name}is undefined`);
  }
  return val;
};

assert = function(val) {
  if (!val) {
    throw new Error('Assertion Error');
  }
  return val;
};

shuffle = function(array) {
  var currentIndex = array.length,  randomIndex;  // While there remain elements to shuffle...

  while (0 !== currentIndex) {

      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;

      // And swap it with the current element.
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }

    return array;
  };

 getRandom = function(arr, n) {
    var result = new Array(n),
        len = arr.length,
        taken = new Array(len);
    if (n > len)
        throw new RangeError("getRandom: more elements taken than available");
    while (n--) {
        var x = Math.floor(Math.random() * len);
        result[n] = arr[x in taken ? taken[x] : x];
        taken[x] = --len in taken ? taken[len] : len;
    }
    return result;
}
// alternative to above
function searchRandom(arr,count){
  let answer = [], counter = 0;
 
  while(counter < count){
    let rand = arr[Math.floor(Math.random() * arr.length)];
    if(!answer.some(an => an === rand)){
      answer.push(rand);
      counter++;
    }
  }
  
  return answer;
}


/* -----Helpful Functions-----*/
function setCharAt(str, index, chr) {
    if (index > str.length - 1) return str;
    return str.substring(0, index) + chr + str.substring(index + 1);
};

function color_rep(str,n) {
    str = setCharAt(str, n, 'g');
    return str
}; // to test this name1 = 

function shape_rep(str,n) {
    str = setCharAt(str, n, 'g');
    return str
}; // to test this name2 = 

function CPT_fre_rep(str,n) {
  str = setCharAt(str, n, 'g');
  return str
};

/* function CPT_infre_rep(str) {
  str = setCharAt(str, 49, 'g');
  return str
}; */

function setCharAt(str, index, chr) {
  if (index > str.length - 1) return str;
  return str.substring(0, index) + chr + str.substring(index + 1);
};


function countItems(arr, what){
  var count= 0, i;
  while((i= arr.indexOf(what, i))!= -1){
      ++count;
      ++i;
  }
  return count
};

function isConsecutive(a){

let visited = {};
if((a[a.length - 1] - a[0]) + 1 != a.length){
 return false;
}
for(let i = 0; i < a.length; i++){
  if(visited[a[i]] == 1){
    return false;
  }else{
    visited[a[i]] = 1;
  }
  return true;
}
};

function getRandom(arr, n) {
  var result = new Array(n),
      len = arr.length,
      taken = new Array(len);
  if (n > len)
      throw new RangeError("getRandom: more elements taken than available");
  while (n--) {
      var x = Math.floor(Math.random() * len);
      result[n] = arr[x in taken ? taken[x] : x];
      taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
};


function shuffle(array) {
var currentIndex = array.length,  randomIndex;

// While there remain elements to shuffle...
while (0 !== currentIndex) {

  // Pick a remaining element...
  randomIndex = Math.floor(Math.random() * currentIndex);
  currentIndex--;

  // And swap it with the current element.
  [array[currentIndex], array[randomIndex]] = [
    array[randomIndex], array[currentIndex]];
}

return array;
};

function range(start, end) {
/* generate a range : [start, start+1, ..., end-1, end] */
var len = end - start + 1;
var a = new Array(len);
for (let i = 0; i < len; i++) a[i] = start + i;
return a;
};

function repeat_push(rslt, item, times) {
for(let i = 0; i < times; i++) {
  rslt.push(item)
}
return rslt;
};

function get_values_bykey(object) {

  var TD_stimuli_list = []
  object.forEach(function myFunction(value) {
      //console.log('this is item number ' + value)
      TD_stimuli_list.push(value.TD_stimulus)

  })
  return TD_stimuli_list;
};

function findWithAttr(array, attr, value) {
  for(var i = 0; i < array.length; i += 1) {
      if(array[i][attr] === value) {
          return i;
      }
  }
  return -1;
};


function get_target_time(animation_sequence,response, TD_target,set) {

  var time = []
  var shapes_reacted_to = []
  var shapes_reacted_to_index = []
  var target_index = findWithAttr(animation_sequence, 'stimulus', TD_target)
  //console.log(target_index)

  function checkindex(index) {
                  var index_after_target = index > target_index
                  return  index_after_target;}

  if (set =='onset') {
      animation_sequence.forEach(function myFunction(value) {
          //console.log('this is shape ' + value)
          if (value.stimulus == TD_target) {
              //get index of target
              time.push(value.time)
      }
  })
}

  if (set =='offset'){
          var shapes_rt_index_after_target = []

          response.forEach(function myFunction(value) {
          var shape = value.stimulus
          //console.log(shape)
          shapes_reacted_to.push(shape)
          var shape_index = findWithAttr(animation_sequence, 'stimulus', shape)
          shapes_reacted_to_index.push(shape_index)

          if (shape == TD_target) {
              time.push(value.rt)
              }
          else if (shape_index > target_index){
              //console.log('this is post target')
              shapes_rt_index_after_target.push(value.rt)
              //console.log(shapes_rt_index_after_target)
          }

  })

          //for every index in shapes_reacted_to_index, if all of them < target_index, then log
          if (shapes_reacted_to_index.every( (val) => val <target_index) && shapes_reacted_to.includes(TD_target) == false ) {
              //console.log('pressed before target')
              //console.log(shapes_reacted_to_index.every( (val) => val <target_index))
          }

          //if any of them > target_index and no press to target, then take the rt of the first after target
          else if(shapes_reacted_to_index.some(checkindex) && shapes_reacted_to.includes(TD_target) == false){ // Returns true
              time.push(shapes_rt_index_after_target[0])
              //console.log(shapes_reacted_to_index.some(checkindex))
              //console.log(shapes_rt_index_after_target)
          }
  };
  return time[0]
};

var getPermutations = function(list, maxLen) {
  // Copy initial values as arrays
  var perm = list.map(function(val) {
      return [val];
  });
  // Our permutation generator
  var generate = function(perm, maxLen, currLen) {
      // Reached desired length
      if (currLen === maxLen) {
          return perm;
      }
      // For each existing permutation
      for (var i = 0, len = perm.length; i < len; i++) {
          var currPerm = perm.shift();
          // Create new permutation
          for (var k = 0; k < list.length; k++) {
              perm.push(currPerm.concat(list[k]));
          }
      }
      // Recurse
      return generate(perm, maxLen, currLen + 1);
  };
  // Start with size 1 because of initial values
  return generate(perm, maxLen, 1);
};

function hasDuplicates(array) {
  return (new Set(array)).size !== array.length;
}

list_of_num_range = function(start, end) {
  var list = [];
  for (var i = start; i <= end; i++) {
      list.push(i);
  }
  return list
}
